@page "/manager"
<MudThemeProvider />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />
@rendermode InteractiveServer

@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Identity
@using BlazorApp.Data
@using Microsoft.EntityFrameworkCore
@using MudBlazor
@inject ApplicationDbContext DbContext
@inject UserManager<ApplicationUser> UserManager
@inject RoleManager<IdentityRole> RoleManager
@attribute [Authorize(Policy = "ManagerOrAbove")]

<PageTitle>Manager Dashboard</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="my-4">
    <MudText Typo="Typo.h3" GutterBottom="true">Manager Dashboard</MudText>
    <MudText>Welcome, Manager! Manage user accounts and roles below.</MudText>

    @if (Users == null)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-7" />
    }
    else
    {
        <MudTable Items="@Users" Dense="true" Hover="true" Striped="true" Bordered="true" Class="mt-4">
            <HeaderContent>
                <MudTh>Username</MudTh>
                <MudTh>Level</MudTh>
                <MudTh>Roles</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.UserName</MudTd>
                <MudTd>@context.Level</MudTd>
                <MudTd>
                    @if (UserRoles.ContainsKey(context.Id) && UserRoles[context.Id].Any())
                    {
                        foreach (var role in UserRoles[context.Id])
                        {
                            <MudChip T="string" Size="Size.Small" Color="GetChipColor(role)">@role</MudChip>
                        }
                    }
                    else
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Default">None</MudChip>
                    }
                </MudTd>
                <MudTd>
                    <MudSelect T="string" Label="Select Roles" Variant="Variant.Outlined" Dense="true" Multiple="true" SelectedValues="@SelectedRoles[context.Id]" SelectedValuesChanged="(newValues) => UpdateSelectedRoles(context.Id, newValues)">
                        @foreach (var role in AvailableRoles)
                        {
                            <MudSelectItem Value="@role" />
                        }
                    </MudSelect>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Small" OnClick="() => UpdateUserRoles(context)" Style="margin-left: 8px;">Update Roles</MudButton>
                </MudTd>
            </RowTemplate>
        </MudTable>
    }

    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <MudAlert Severity="Severity.Error" Class="mt-4">@ErrorMessage</MudAlert>
    }
</MudContainer>

@code {
    private List<ApplicationUser> Users = null!;
    private Dictionary<string, List<string>> UserRoles = new();
    private Dictionary<string, HashSet<string>> SelectedRoles = new();
    private List<string> AvailableRoles = new() { "Manager", "User" };
    private string? ErrorMessage;

    protected override async Task OnInitializedAsync()
    {
        // Fetch users with Level != 0 and their roles in a single query
        var usersWithRoles = await DbContext.Users
            .Where(u => u.Level != 0)
            .OrderBy(u => u.Level)
            .Select(u => new
            {
                User = u,
                Roles = DbContext.UserRoles
                    .Where(ur => ur.UserId == u.Id)
                    .Join(DbContext.Roles,
                          ur => ur.RoleId,
                          r => r.Id,
                          (ur, r) => r.Name!)
                    .ToList()
            })
            .ToListAsync();

        Users = usersWithRoles.Select(x => x.User).ToList();
        foreach (var user in usersWithRoles)
        {
            UserRoles[user.User.Id] = user.Roles;
            SelectedRoles[user.User.Id] = new HashSet<string>(user.Roles);
        }
    }

    private Task UpdateSelectedRoles(string userId, IEnumerable<string> newValues)
    {
        SelectedRoles[userId] = new HashSet<string>(newValues);
        return Task.CompletedTask;
    }

    private async Task UpdateUserRoles(ApplicationUser user)
    {
        try
        {
            var currentRoles = await UserManager.GetRolesAsync(user);
            var selectedRoles = SelectedRoles[user.Id].ToList();

            var rolesToAdd = selectedRoles.Except(currentRoles).ToList();
            var rolesToRemove = currentRoles.Except(selectedRoles).ToList();

            if (rolesToAdd.Any())
            {
                var addResult = await UserManager.AddToRolesAsync(user, rolesToAdd);
                if (!addResult.Succeeded)
                {
                    ErrorMessage = $"Failed to add roles: {string.Join("; ", addResult.Errors.Select(e => e.Description))}";
                    return;
                }
            }

            if (rolesToRemove.Any())
            {
                var removeResult = await UserManager.RemoveFromRolesAsync(user, rolesToRemove);
                if (!removeResult.Succeeded)
                {
                    ErrorMessage = $"Failed to remove roles: {string.Join("; ", removeResult.Errors.Select(e => e.Description))}";
                    return;
                }
            }

            // Update level based on roles
            if (selectedRoles.Contains("Manager"))
            {
                user.Level = 1;
            }
            else
            {
                user.Level = 2;
            }
            await UserManager.UpdateAsync(user);

            UserRoles[user.Id] = selectedRoles.ToList();
            ErrorMessage = null;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"An error occurred: {ex.Message}";
        }
    }

    private Color GetChipColor(string role)
    {
        return role switch
        {
            "Manager" => Color.Warning,
            _ => Color.Success
        };
    }
}